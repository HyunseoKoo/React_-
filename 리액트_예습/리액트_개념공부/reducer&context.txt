

1. FLUX 패턴에 대하여 설명해보세요

2. 아래의 hook 함수는 각각 어느 순간에 사용할까요
    (1) useReducer
    (2) useContext

 (1) useReducer : 컴포넌트의 상태 업데이트 로직을 컴포넌트에서 분리.
                  상태 업데이트 로직을 컴포넌트 바깥에 작성할 수 있고, 심지어 다른 파일에 작성 후 불러와서 사용 가능.
                  

3. 전역 상태 관리를 해야하는 이유는 무엇일까요

4. 그렇다면 전역 상태 관리는 위 조건에만 부합하면 반드시 수행하는 것이 좋을까요?
   전역 상태 관리를 통해 얻을 수 있는 장단점에 관하여 토의해보세요








  /*
    문제 2 - 2
      1. Form1에서 값을 입력하면 userList에 데이터가 추가되도록 구현해보세요
      2. Form2에서 버튼을 클릭하면 userList의 각 요소에 isEdit: true의 속성이 추가되도록 구현해보세요
      3. Form3에서 reset 버튼을 클릭하면 userList를 초기화 시키도록 구현해보세요
      4. 제출 버튼을 누르면 isEdit true인 userList만 console.log로 출력해보세요
        (단, isEdit이 true인 데이터도 전역으로 관리해주세요.)
  */

    /*
    단, userList 상태 관리는 전역으로 관리하고 비즈니스 로직도 분리하기 위해
    useReducer, useContext를 사용하여 구현해보세요

    (일반 state를 사용하는 문제가 아니기 때문에 전역으로 상태관리를 할 수 있도록 해주세요)

    관련 로직은 src/store/3_context.js에 구현해주세요
  */


1. context.js 파일에 Context & Reducer 세팅
 1) createContext 로 전역저장소 생성
 2) provider로 해당 파일 return부분에 provider로 덮개 만들어줌 {children} 세팅하고 export default 설정
 3) initialUser 변수 선언해서 초기값 세팅 (id, name, nickname~~)
 4) Reducer함수 선언, action의 case 정리
 5) useReducer 함수 선언 후 이걸 value로 넣어줌??? 

 2. App.js에 가서 createdContext 저장소 만든 변수로 provider 덮개 씌움

 3. Q3.js에 가서 5)번 value를 받기 위해서 useContext(설정해준변수)로 저장소의 값 가져옴 (dispatch / ? - 2개인거 같은데 생각 안남)

 4. [추가] 버튼 기능 구현 - dispatch action중 ADD_USER 수행
    input 태그에 입력되는 name, nickname값 받아올 매개변수 필요.
    이거는 props로 form2파일(?)에서 받아와야 함
    form2파일로 이동. 이벤트 함수 선언. e.target.name이름.value로 가져옴
    다시 이전 파일로 돌아와서 payload로 name, nickname 세팅
    context 파일에서 dispatch case에 id, name, nickname 추가하는 코드 작성
   
 5. [STATUS] 버튼 기능 구현 - context에서 dispatch action 작성 (isEdit: true 객체 키값 추가)
    이벤트 함수 작성

6. [RESET] 버튼 구현 -  context에서 dispatch action 작성 (초기값 변수로 세팅)
    이벤트 함수 작성
    
7. [SUBMIT] 버튼 구현 -  context에서 dispatch action 작성 (isEdit이 true인 객체 찾기)
    이벤트 함수 작성


=============================================

1. 전역 상태관리(useContext), reducer 사용
2. dispatch로 전달받을 로직 작성