컨텍스트: 전역으로 state(상태)를 전달하기 위한 것
리듀서: 상태의 비즈니스 로직을 밖으로 빼내기 위한것

dayjs ㅇ
luxon

83ac3bc139060adf9799326048ea6950fe507907

useReducer 을 사용했을 때의 가장 큰 장점은 컴포넌트 업데이트 로직을 컴포넌트 바깥으로 빼낼 수 있다는 점 입니다.

------------------------------------------------------------------------------------------------------------------------------
[react > reducer]
1. [components]폴더 > [counter]파일에 useReducer 사용
function Counter() {
const [count, dispatch] = useReducer(countReducer, 0);

const onIncrementCount = () => {
   dispatch({
	type: 'INCREMENT',
	count: 1,
   });
};

const onDecrementCount = () => {
   dispatch({
	type: 'DECREMENT',
	count: 1,
   });
};

return (
   <>
	<button onClick={onIncrementCount}>+</button>
	{count}
	<button onClick={onDecrementCount}-</button>


2. [reducer]폴더 > countReducer 함수 만듦 (useReducer의 dispatch가 전달할 함수 (매개변수 state는 useReducer에서 갖는 초기값 변수, action은 dispatch가 전달한 객체_action.type & action.count))
export const countReducre = (state, action) => {
   switch (action.type) {
	case 'INCREMENT':
	   return state + action.count;
	case 'DECREMENT':
	   return state - action.count;
	default:
	   return state;
   }
};

------------------------------------------------------------------------------------------------------------------------------

1. [components]폴더 > [user]폴더 > userList 파일 만듦
 userList를 뿌려주는 역할
2. [components]폴더 > [user]폴더 > addUser 파일 만듦



[context 만들기]
3. [context]폴더 > user파일 만듦
const initialState = [
  {
    id: 1,
    name: '김성용',
  },
  {
    id: 2,
    name: '구현서',
  },
  {
    id: 3,
    name: '김태기',
  },
  {
    id: 4,
    name: '김민식',
  },
];

 1) createContext() => 전역 저장소를 만듦
 	export const UserContext = createContext();
	export const useUserState = useContext(UserContext);	=> userUserState를 어떤 컴포넌트에서 가져다쓰면, userContext라는 (비어있는) 저장소의 데이터에 접근하겠다!
	const ContextProvider = ({children}) => {
		const [state, setState] = useState(initialState);	=> initialState를 state화 한 것.
		return <UserContext.Provider value={[state, setState]}>{children}</UserContext.Provider> 	=> UserContext라는 비어있는 저장소에 initialState라는 값을 채워넣음!
	}; 	=> UserContext가 모든 컴포넌트와 공유됨!
	export default ContextProvider;		=> UserContext가 모든 컴포넌트와 공유될수 있도록 해주는 함수 ContextProvider를 바깥으로 내보내고, 모든 컴포넌트가 만나는 App.js에 가져다 씀!

 2) App.js 파일에 ContextProvdier 세팅
	function App() {
	   return (
		<ContextProvider>
		   <div className="App">
			<User />
		   </div>
	 	</ContextProvider>
	   );
	}
 3) useReducer 사용 => 전역 상태 관리를 위해 밖에서 state 관리	[user]폴더 > index파일로 이동
	fucntion User(){
	   const userList = useContext(UserContext);		// userList를 콘솔로 찍으면 (2) [Array(4), f] => 길이가 2인 배열. 0번째 인덱스에는 initial값으로 넣어던 이름 객체배열, 1번째 인덱스에는 state로 관리해주는 값
	   (따라서, const [userList, setUserList] = useContext(UserContext) 로 구조분해해서 쓸수 있음)	=> userList에 첫번째 인덱스값인 state, setUserList에 두번째 인덱스값인 setState 들어가짐 [구조분해?]

4) [components]폴더 > [user]폴더 > userList파일에 const [userList] = useContext(UserContext); 가져다 씀. 그럼 기존에 props로 받은 {userList} 삭제 가능
										                           -----------  ------------- 두개 다 import 해줘야함!


[Reduce 만들기] => 전역 상태를 관리하는 로직은 따로 빼자! 왜? 전역상태는 다른 컴포넌트에서 쓰려고 쓰는거니까, 어차피 변경하는 로직도 재사용하잖아, 그 재사용 로직을 reducer로 따로빼서 한꺼번에 관리하자!
			  전역 상태를 관리하는 로직은 어차피 전역상태니까 따로 빼서 쓰자!!

 5) const [state, setState] = useState(inintialState); 를 reducer로 관리!
 user파일에서 다음과 같이 변경

// (2번) reducer함수 만들기
const userListReducer = (state, action) => {
	switch(action.type){
	   case 

 const ContextProvider = ({children}) => {
		// const [state, setState] = useState(initialState); => 이거를 
		const [state, dispatch] = useReducer("", initialState) => 이렇게 교체하고 나서! (1번)
		return <UserContext.Provider value={[state, setState]}>{children}</UserContext.Provider> 
	}; 	
	export default ContextProvider;	

